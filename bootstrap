#!/bin/bash -x
##
## This script creates bootstrap archives from the locally running chain in
## tar.gz and zip format.
## After the acrves are made, the MD5, SHA256 and SHA512 checksums are
## calculated.
## Of the archives a Verus Signature will be created if that option is enabled
## in the <COINTICKER>.json
## It creates a basic page, based on the customizable
## `bootstrap.html.template` with this data:
##  - Cointicker and coin name
##  - Basic links to the project
##  - Bootstrap data like creation timestamp, blockheight and best hash
##  - The bootstrap archives, their checksums and signature
## After staging the page, it will move the current bootstrap webfolder to
## `last.<cointicker>-bootstrap` and the staging folder will be renamed
## to `<cointicker>-bootstrap` in the web root location supplied in the
## json for the coin.
##
## options in the json:
## - "sign": true|false (sign with VerusID)
## - "archive": true|false (tar the webfolder for external deployment)
## - "reindex": true|false (reindex the chain after creating bootstrap)
## - "links": list of tags and links to display on the webpage
##
## Usage: `./bootstrap <Cointicker>`
## the `<CoinTicker>.json` must be present in the same folder as the
## `bootstrap` script. Configure your own `<CoinTicker>.json` and fill with
## the required information. The entered values are case sensitive and paths
## are absolute paths.
## Supply a `<CoinTicker>.png` in the `img` folder for a logo on the page.
## if no command line argument is entered, the script will exit.

## check for command line input
FILE=$1
if [ -z "$FILE" ]; then
    echo "No coin supplied to create Bootstrap for."
    exit 1
fi

## needed binaries
# Dependencies: jq, zip, curl, bc and tr.
if ! command -v jq &>/dev/null ; then
    echo "jq not found. please install using your package manager."
    exit 1
fi
if ! command -v zip &>/dev/null ; then
    echo "zip not found. please install using your package manager."
    exit 1
fi
if ! command -v curl &>/dev/null ; then
    echo "curl not found. please install using your package manager."
    exit 1
fi
if ! command -v bc &>/dev/null ; then
    echo "bc not found. please install using your package manager."
    exit 1
fi
if ! command -v tr &>/dev/null ; then
    echo "tr not found. please install using your package manager."
    exit 1
fi
ZIP=$(which zip)
JQ=$(which jq)
CURL=$(which curl)
BC=$(which bc)
TR=$(which tr)

## Set script folder
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
## Variables declaration
COIN=$(${JQ} -r .coin "${SCRIPT_DIR}/${FILE}.json")
COIN_NAME=$(${JQ} -r .coin_name "${SCRIPT_DIR}/${FILE}.json")
DAEMON_USER=$(${JQ} -r .daemon_user "${SCRIPT_DIR}/${FILE}.json")
DAEMON=$(${JQ} -r .daemon "${SCRIPT_DIR}/${FILE}.json")
RPC_CLIENT=$(${JQ} -r .rpc_client "${SCRIPT_DIR}/${FILE}.json")
CHAIN_FOLDER=$(${JQ} -r .chain_folder "${SCRIPT_DIR}/${FILE}.json")
TEMPLATE_FOLDER=$(${JQ} -r .template_folder "${SCRIPT_DIR}/${FILE}.json")
STAGING_FOLDER=$(${JQ} -r .staging_folder "${SCRIPT_DIR}/${FILE}.json")
WEB_ROOT=$(${JQ} -r .web_root "${SCRIPT_DIR}/${FILE}.json")
SIGNEE=$(${JQ} .signee "${SCRIPT_DIR}/${FILE}.json")
REINDEX=$(${JQ} .reindex "${SCRIPT_DIR}/${FILE}.json")
SIGN=$(${JQ} .sign "${SCRIPT_DIR}/${FILE}.json")
ARCHIVE=$(${JQ} .archive "${SCRIPT_DIR}/${FILE}.json")

## Create staging folder (delete if it exists)
if [[ -d "${STAGING_FOLDER}" ]]
then
    rm -rf "${STAGING_FOLDER}"
fi
cp -r "${TEMPLATE_FOLDER}" "${STAGING_FOLDER}"

## Check if the daemon is running. If not exit, otherwise continue
dstat=0
count=$(su -c "${RPC_CLIENT} -chain=${COIN} -datadir=${CHAIN_FOLDER} getconnectioncount" "${DAEMON_USER}")
case $count in
    ''|*[!0-9]*) dstat=0 ;;
    *) dstat=1 ;;
esac
if [[ "$dstat" == "0" ]]; then
        exit 1
fi

## Check if the chain is completely synchronized and wait for full synchronization if needed.
## Currently only supported for the main VRSC chain, if any other chain is specified
## These tests will be bypassed. Checking requires public block explorers available.

if [ "$COIN" == "VRSC" ]; then
  CHECK_STATUS="UNKNOWN"
  while [[ ! "$CHECK_STATUS" == "OK" ]]; do
    # collect data
    HEIGHT_LOCAL=$(su -c "${RPC_CLIENT} -chain=${COIN} -datadir=${CHAIN_FOLDER} getinfo | ${JQ} .blocks" "${DAEMON_USER}")
    HEIGHT_REMOTE=$(${CURL} --silent https://explorer.verus.io/api/getblockcount)
    HEIGHT_DISTANCE=$(echo "${HEIGHT_LOCAL}-${HEIGHT_REMOTE}" | ${BC} | ${TR} -d -)
    # determine status
    # either output empty = unknown
    if [ -z "${HEIGHT_LOCAL}" ] || [ -z "${HEIGHT_REMOTE}" ]; then
      CHECK_STATUS="UNKNOWN"
    # equal output = OK
    elif [ "${HEIGHT_LOCAL}" -eq "${HEIGHT_REMOTE}" ]; then
      CHECK_STATUS="OK"
    else
    # distance < 3 = warning
      if [ "${HEIGHT_DISTANCE}" -lt "3" ]; then
        CHECK_STATUS="WARN"
        # distance > 3 = critical
      else
        CHECK_STATUS="CRIT"
      fi
    fi
    sleep 15s
  done

  ## Check if the node is forked, exit if forking is detected
  ## Currently only supported for the main VRSC chain.

  CHECK_STATUS="UNKNOWN"
  while [[ ! "$CHECK_STATUS" == "OK" ]]; do
    # collect data
    HASH_LOCAL=$(su -c "${RPC_CLIENT} -chain=${COIN} -datadir=${CHAIN_FOLDER} getbestblockhash" "${DAEMON_USER}")
    HEIGHT_REMOTE=$(${CURL} --silent "https://explorer.verus.io/api/getblockcount")
    HASH_REMOTE=$(${CURL} --silent "https://explorer.verus.io/api/getblockhash?index=${HEIGHT_REMOTE}" | ${JQ} -r .)

    # determine status
    # either output empty = unknown
    if [ -z "${HASH_LOCAL}" ] || [ -z "${HASH_REMOTE}" ]; then
      CHECK_STATUS="UNKNOWN"
    # equal output = OK
    elif [ "${HASH_LOCAL}" == "${HASH_REMOTE}" ]; then
      CHECK_STATUS="OK"
    # nonequal output = critical
    else
      CHECK_STATUS="CRIT"
      exit 1
    fi
    sleep 5s
  done
fi


## Record Bootstrap snapshot data

echo "{" | tee $STAGING_FOLDER/$COIN.json
echo "  \"coin\": \"${COIN}\"," | tee -a "${STAGING_FOLDER}/${COIN}.json"
echo "  \"bootstrap_timestamp\": \"$(${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} getblock $(${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} getblockcount) 1 | jq -r .time)\"," | tee -a "${STAGING_FOLDER}/${COIN}.json"
echo "  \"bootstrap_height\": \"$(${RPC_CLIENT} -chain=${COIN} -datadir=${CHAIN_FOLDER} getblockcount)\"," | tee -a "${STAGING_FOLDER}/${COIN}.json"
echo "  \"bootstrap_bestblockhash\": \"$(${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} getblockhash $(${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} getblockcount))\"," | tee -a "${STAGING_FOLDER}/${COIN}.json"
echo "    \"bootstrap_types\": \"tar.gz zip\"" | tee -a "${STAGING_FOLDER}/${COIN}.json"
echo '}' | tee -a "${STAGING_FOLDER}/${COIN}.json"

## Stopping daemon
su -c "${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} stop" "${DAEMON_USER}"

## Monitoring if the daemon is still running, before continuing
while ps -u "${DAEMON_USER}" x | grep "${DAEMON}" | grep "${CHAIN_FOLDER}\ "; do
    sleep 2s
done

## Creating bootstrap archives
cd "${CHAIN_FOLDER}"
tar -czvf "${COIN}-bootstrap.tar.gz" blocks chainstate
${ZIP} -r "${COIN}-bootstrap.zip"  blocks chainstate


## Starting daemon back up
su -c "cd ${CHAIN_FOLDER} && ${DAEMON}  -chain=${COIN} -datadir=${CHAIN_FOLDER} -daemon 1>/dev/null 2>&1" "${DAEMON_USER}"

## Moving bootstrap archives to bootstrap folder
mv "${CHAIN_FOLDER}/${COIN}-bootstrap.*" "${STAGING_FOLDER}"

## Creating checksum files
cd "${STAGING_FOLDER}"
md5sum -b "${COIN}-bootstrap.tar.gz" >"${COIN}-bootstrap.tar.gz.md5sum"
sha256sum -b "${COIN}-bootstrap.tar.gz" >"${COIN}-bootstrap.tar.gz.sha256sum"
sha512sum -b "${COIN}-bootstrap.tar.gz" >"${COIN}-bootstrap.tar.gz.sha512sum"

md5sum -b "${COIN}-bootstrap.zip" >"${COIN}-bootstrap.zip.md5sum"
sha256sum -b "${COIN}-bootstrap.zip" >"${COIN}-bootstrap.zip.sha256sum"
sha512sum -b "${COIN}-bootstrap.zip" >"${COIN}-bootstrap.zip.sha512sum"

## Check if the daemon is started in a loop
## If false wait 15 seconds and repeat loop
## If true proceed to signing the archives
dstat=0
until [ $dstat == 1 ]; do
  count=$("${RPC_CLIENT}" -datadir="${CHAIN_FOLDER}" getconnectioncount)
  case $count in
    ''|*[!0-9]*) dstat=0
       sleep 15s ;;
    *) dstat=1 ;;
  esac
done

## check if signature creating is enabled and create VerusID signatures
if "${SIGN}"
then
  bash -c "${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} signfile ${SIGNEE} ${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz" > "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.tmp"
  if [[ -f "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.tmp" ]]
  then
      { head -n 1 "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.tmp"; echo "  \"signee\": ${SIGNEE},"; tail -n +2 "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.tmp"; } > "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.verusid"
  fi
  bash -c "${RPC_CLIENT}  -chain=${COIN} -datadir=${CHAIN_FOLDER} signfile ${SIGNEE} ${STAGING_FOLDER}/${COIN}-bootstrap.zip"> "${STAGING_FOLDER}/${COIN}-bootstrap.zip.tmp"
  if [[ -f "${STAGING_FOLDER}/${COIN}-bootstrap.zip.tmp" ]]
  then
    { head -n 1 "${STAGING_FOLDER}/${COIN}-bootstrap.zip.tmp"; echo "  \"signee\": ${SIGNEE},"; tail -n +2 "${STAGING_FOLDER}/${COIN}-bootstrap.zip.tmp"; } > "${STAGING_FOLDER}/${COIN}-bootstrap.zip.verusid"
  fi
  rm "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.tmp" "${STAGING_FOLDER}/${COIN}-bootstrap.zip.tmp"
fi

## depending on the value of $REINDEX, stop the chain and start it with the `-reindex` parameters
if [[ "${REINDEX}" == "false" ]]
then
  ## Reindex is disabled
  sleep 1s
else
  ## Stopping daemon
  su -c "${RPC_CLIENT} -chain=${COIN} -datadir=${CHAIN_FOLDER} stop" "${DAEMON_USER}"
  ## Monitoring if the daemon is still running, before continuing
  while ps -u "${DAEMON_USER}" x | grep "${DAEMON}" | grep "${CHAIN_FOLDER}\ "; do
    sleep 2s
  done
  ## Starting daemon back up with -reindex
  su -c "cd ${CHAIN_FOLDER} && ${DAEMON} -chain=${COIN} -datadir=${CHAIN_FOLDER} -reindex -daemon 1>/dev/null 2>&1" "${DAEMON_USER}"
fi

## Collect data about the bootstrap (recorded at daemon shutdown, filesizes read directly from files)
COIN=$(${JQ} -r .coin "${STAGING_FOLDER}/${COIN}.json")
BOOTSTRAP_TIMESTAMP=$(date -d @$(${JQ} -r .bootstrap_timestamp "${STAGING_FOLDER}/${COIN}.json"))
BOOTSTRAP_HEIGHT=$(${JQ} -r .bootstrap_height "${STAGING_FOLDER}/${COIN}.json")
BOOTSTRAP_BESTBLOCKHASH=$(${JQ} -r .bootstrap_bestblockhash "${STAGING_FOLDER}/${COIN}.json")
ZIP_SIZE=$(ls -lah "${STAGING_FOLDER}/${COIN}-bootstrap.zip" | awk '{ print $5}')
TGZ_SIZE=$(ls -lah "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz" | awk '{ print $5}')

## Create populated $COIN.html from local template file
mv "${STAGING_FOLDER}/bootstrap.html.template" "${STAGING_FOLDER}/${COIN}.html"

## Remove signature lines from template if signature files are not present.
if [ ! -f "${STAGING_FOLDER}/${COIN}-bootstrap.tar.gz.verusid" ]
then
  sed -i '/<li>Signatures/d' "${STAGING_FOLDER}/${COIN}.html"
fi

## replace placeholders for values with recorded values
sed -i "s/%%BOOTSTRAP_TIMESTAMP%%/${BOOTSTRAP_TIMESTAMP}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%BOOTSTRAP_BESTBLOCKHASH%%/${BOOTSTRAP_BESTBLOCKHASH}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%BOOTSTRAP_HEIGHT%%/${BOOTSTRAP_HEIGHT}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%ZIP_SIZE%%/${ZIP_SIZE}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%TGZ_SIZE%%/${TGZ_SIZE}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%COIN%%/${COIN}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i "s/%%COIN_NAME%%/${COIN_NAME}/gip" "${STAGING_FOLDER}/${COIN}.html"
sed -i '$!N; /^\(.*\)\n\1$/!P; D' "${STAGING_FOLDER}/${COIN}.html"

## Fill $COIN.html with links from $COIN.json
m=$(${JQ} -r ".links | length" "${SCRIPT_DIR}/${FILE}.json")
for (( n=m-1; n>=0; n-- ))
do
  tag=$(${JQ} -r ".links[$n].tag" "${SCRIPT_DIR}/${FILE}.json")
  url=$(${JQ} -r ".links[$n].URL" "${SCRIPT_DIR}/${FILE}.json")
  mv "${STAGING_FOLDER}/${COIN}.html" "${STAGING_FOLDER}/${COIN}.tmp"
  { head -n 30 "${STAGING_FOLDER}/${COIN}.tmp"; echo -e "\t\t\t\t\t<li>$tag: <a href=\"$url\" target=\"_blank\">$url</a></li>"; tail -n +31 "${STAGING_FOLDER}/${COIN}.tmp"; } > "${STAGING_FOLDER}/${COIN}.html"
  rm -f "${STAGING_FOLDER}/${COIN}.tmp"
done

## Sanitizing of staging folder before deployment
rm "${STAGING_FOLDER}/${COIN}.json"

## Moving folders for deployment
rm -rf "${WEB_ROOT}/last.${COIN}-bootstrap"
mv "${WEB_ROOT}/${COIN}-bootstrap" "${WEB_ROOT}/last.${COIN}-bootstrap"
mv "${STAGING_FOLDER}" "${WEB_ROOT}/${COIN}-bootstrap"

## Create symlink
cd "${WEB_ROOT}/${COIN}-bootstrap"
ln -s "${COIN}.html" index.html
cd /

## Set priviliges
chown -R www-data:www-data "${WEB_ROOT}/${COIN}-bootstrap"

## create an archive for the entire website, for easy distribution
if "${ARCHIVE}"
then
  ## remove web archive from the last.$COIN-bnootstrap to conserve drivespace
  if [ ! -f "${WEB_ROOT}/last.${COIN}-bootstrap/${COIN}-bootstrap.tar" ]
  then
    rm -f "${WEB_ROOT}/last.${COIN}-bootstrap/${COIN}-bootstrap.tar"
  fi
  ## create archive
  cd "${WEB_ROOT}"
  tar -cvf "${COIN}-bootstrap.tar" "${COIN}-bootstrap"
  mv "${WEB_ROOT}/${COIN}-bootstrap.tar" "${WEB_ROOT}/${COIN}-bootstrap"
fi
